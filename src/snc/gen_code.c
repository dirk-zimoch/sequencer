/*************************************************************************\
Copyright (c) 1990      The Regents of the University of California
                        and the University of Chicago.
                        Los Alamos National Laboratory
Copyright (c) 2010-2015 Helmholtz-Zentrum Berlin f. Materialien
                        und Energie GmbH, Germany (HZB)
This file is distributed subject to a Software License Agreement found
in the file LICENSE that is included with this distribution.
\*************************************************************************/
/*************************************************************************\
                Code generation
\*************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "node.h"
#include "analysis.h"
#include "gen_ss_code.h"
#include "gen_tables.h"
#include "main.h"
#include "var_types.h"
#include "gen_code.h"

static const int impossible = 0;

static void gen_main(char *prog_name);
static void gen_var_struct(Node *prog, uint opt_reent);
static void gen_init_reg(char *prog_name);
static void gen_func_decls(Node *prog);
static void gen_global_defn(uint ctx, Node *ep);

static int assert_var_declared(Node *ep, Node *scope, void *parg)
{
#ifdef DEBUG
	report("assert_var_declared: '%s' in scope (%s:%s)\n",
		ep->token.str, node_name(scope), scope->token.str);
#endif
	assert(ep->tag == E_VAR);
	assert(ep->extra.e_var != 0);
	return TRUE;		/* there are no children anyway */
}

/* Generate C code from parse tree. */
void generate_code(Program *p)
{
	Node *defn;
	uint ctx;

	/* assume there have been no errors, so all vars are declared */
	traverse_syntax_tree(p->prog, bit(E_VAR), 0, 0, assert_var_declared, 0);

#ifdef DEBUG
	report("-------------------- Code Generation --------------------\n");
#endif

	/* Initial comments */
	gen_code("/* C code for program %s, ", p->name);
	gen_code("generated by snc from %s */\n", p->prog->token.file);

	/* Includes */
	gen_code("#include <string.h>\n");
	gen_code("#include <stddef.h>\n");
	gen_code("#include <stdlib.h>\n");
	gen_code("#include <stdio.h>\n");
	gen_code("#include <limits.h>\n");
	gen_code("\n");
	gen_code("#include \"seq_snc.h\"\n");

	ctx = default_context(p->options);

	/* Initial definitions *except* global variable declarations,
	   in the order in which they appear in the program.
	   Note: this includes escaped C code. */
	foreach (defn, p->prog->prog_defns) gen_global_defn(ctx, defn);

	/* Variable declarations */
	gen_var_struct(p->prog, p->options->reent);

	/* Function declarations */
	gen_func_decls(p->prog);

	/* State and state set functions */
	gen_ss_code(ctx, p->prog, p->chan_list, p->evflag_list);

	/* Channel, state set, and program tables */
	gen_tables(p);

	/* Extra definitions */
	foreach (defn, p->prog->prog_xdefns) gen_global_defn(ctx, defn);

	/* Main function */
	if (p->options->main) gen_main(p->name);

	/* Sequencer registration */
	gen_init_reg(p->name);
}

/* Generate main program */
static void gen_main(char *prog_name)
{
	gen_code("\n#define PROG_NAME %s\n", prog_name);
	gen_code("#include \"seqMain.c\"\n");
}

static void gen_pv_decl(Var *vp)
{
	gen_pv_type(vp->type, "", vp->name);
}

void gen_var_decl(Var *vp)
{
	gen_type(vp->type, "", vp->name);
}

static void gen_func_decls(Node *prog)
{
	Var	*vp;

	assert(prog->tag == D_PROG);
	gen_code("\n/* Function declarations */\n");

	/* function declarations are always global and static */
	foreach (vp, var_list_from_scope(prog)->first)
	{
		if (vp->decl && vp->type->tag == T_FUNCTION)
		{
			gen_line_marker(vp->decl);
			gen_code("static ");
			gen_var_decl(vp);
			gen_code(";\n");
		}
	}
}

static void gen_var_and_pv_decl(Var *vp, int level)
{
	/* C variable declaration */
#if 0
	if (vp->type->tag != T_POINTER || !type_contains_pv(vp->type))
	{
#endif
		gen_line_marker(vp->decl);
		if (level)
			indent(level);
		else
			gen_code("static ");
		gen_var_decl(vp);
		gen_code(";\n");
#if 0
	}
#endif

	/* channel declaration */
	if (type_contains_pv(vp->type))
	{
		gen_line_marker(vp->decl);
		if (level)
			indent(level);
		else
			gen_code("static ");
		gen_pv_decl(vp);
		gen_code(";\n");
	}
}

/* Generate the struct containing all program variables with
   'infinite' (global) lifetime. These are: variables declared at the
   top-level, inside a state set, and inside a state. Note that state
   set and state local variables are _visible_ only inside the block
   where they are declared, but still have global lifetime. To avoid
   name collisions, generate a nested struct for each state set, and
   for each state in a state set. */
static void gen_var_struct(Node *prog, uint opt_reent)
{
	Var	*vp;
	Node	*sp, *ssp;
	int	level = opt_reent;

	gen_code("\n/* Variable declarations */\n");
	if (opt_reent)
	{
		gen_code("struct %s {\n", NM_VARS);
		indent(1); gen_code("char "NM_DUMMY";\n");
	}
	foreach (vp, var_list_from_scope(prog)->first)
	{
		if (vp->decl && vp->type->tag != T_NONE && vp->type->tag != T_FUNCTION)
			gen_var_and_pv_decl(vp, level);
	}
	foreach (ssp, prog->prog_statesets)
	{
		indent(level);
		if (!opt_reent)
			gen_code("static ");
		gen_code("struct %s_%s {\n", NM_VARS, ssp->token.str);
		indent(level+1); gen_code("char "NM_DUMMY";\n");
		foreach (vp, ssp->extra.e_ss->var_list->first)
			gen_var_and_pv_decl(vp, level+1);
		foreach (sp, ssp->ss_states)
		{
			indent(level+1); gen_code("struct {\n");
			indent(level+2); gen_code("char "NM_DUMMY";\n");
			foreach (vp, sp->extra.e_state->var_list->first)
				gen_var_and_pv_decl(vp, level+2);
			indent(level+1);
			gen_code("} %s_%s;\n", NM_VARS, sp->token.str);
		}
		indent(level); gen_code("} %s_%s", NM_VARS, ssp->token.str);
		gen_code(";\n");
	}
	if (opt_reent)
		gen_code("};\n");
	gen_code("\n");
}

static void gen_global_defn(uint ctx, Node *ep)
{
	Node *member;

	switch(ep->tag)
	{
	case T_TEXT:
		gen_line_marker(ep);
		gen_code("%s\n", ep->token.str);
		break;
	case D_ENUMDEF:
		/* TODO: generate enum definition */
		break;
	case D_FUNCDEF:
		gen_funcdef(ctx, ep);
		break;
	case D_STRUCTDEF:
		gen_code("\nstruct %s {\n", ep->token.str);
		foreach (member, ep->structdef_members)
		{
			gen_line_marker(member);
			switch (member->tag)
			{
			case D_DECL:
				gen_var_and_pv_decl(member->extra.e_decl, 1);
				break;
			case T_TEXT:
				indent(1);
				gen_code("%s\n", member->token.str);
				break;
			default:
				error_at_node(member, "member->tag==%s\n",
					node_name(member));
				assert(impossible);
			}
		}
		gen_code("};\n");
		break;
	case D_DECL:
	case D_ASSIGN:
	case D_MONITOR:
	case D_OPTION:
	case D_SYNC:
	case D_SYNCQ:
		/* these have no direct correspondence to a C declaration */
		break;
	default:
		report_at_node(ep, "ep->tag==%s\n", node_name(ep));
		assert(impossible);
	}
}

static void gen_init_reg(char *prog_name)
{
	gen_code("\n/* Register sequencer commands and program */\n");
	gen_code("#include \"epicsExport.h\"\n");
	gen_code("static void %sRegistrar (void) {\n", prog_name);
	gen_code("    seqRegisterSequencerCommands();\n");
	gen_code("    seqRegisterSequencerProgram (&%s);\n", prog_name);
	gen_code("}\n");
	gen_code("epicsExportRegistrar(%sRegistrar);\n", prog_name);
}

void indent(int level)
{
	while (level-- > 0)
		gen_code("\t");
}
