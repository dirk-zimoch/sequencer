/*************************************************************************\
Copyright (c) 2010-2012 Helmholtz-Zentrum Berlin f. Materialien
                        und Energie GmbH, Germany (HZB)
This file is distributed subject to a Software License Agreement found
in the file LICENSE that is included with this distribution.
\*************************************************************************/
/*************************************************************************\
                    Parser specification/implementation
\*************************************************************************/
%include {
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "node.h"
#include "var_types.h"
#include "main.h"
#include "parser.h"
}

%extra_argument { Node **presult }

%name snlParser

%token_prefix TOK_

%parse_failure {
	report("parser giving up\n");
	exit(1);
}

%syntax_error {
	error_at(TOKEN.file, TOKEN.line,
		"syntax error near token '%s'\n", TOKEN.str);
	report_loc(TOKEN.file, TOKEN.line);
}

// %stack_overflow {
// 	   report("parser stack overflow\n");
// }

// A stack size of 0 (zero) means stack size gets dynamically increased
// on demand i.e. stack size is essentially unlimited. This is important
// because some rules like the one for IF/ELSE statements employ left-recursion.
%stack_size 0

%token_type { Token }
%default_type { Node* }

/* Standard C operator table, highest precedence first.
  Primary Expression Operators  () [] . -> expr++ expr--  left-to-right
  Unary Operators  * & + - ! ~ ++expr --expr (typecast) sizeof()  right-to-left
  Binary Operators  * / %  left-to-right
  + -
  >> <<
  < > <= >=
  == !=
  &
  ^
  |
  &&
  ||
  Ternary Operator  ?:  right-to-left
  Assignment Operators  = += -= *= /= %= >>= <<= &= ^= |=  right-to-left
  Comma  ,  left-to-right
*/

// PRE and POST are pseudo tokens used for precedence declaration.
// They are needed for operators that can appear in more than
// one position (and then have different precedences) because lemon
// allows only one precedence declaration for each token.

// The comma operator is implemented as an extra production,
// so we need no explicit precedence for it.
// %left	COMMA.
%right	EQUAL ADDEQ SUBEQ ANDEQ OREQ DIVEQ MULEQ MODEQ LSHEQ RSHEQ XOREQ.
%right	QUESTION COLON.
%left	OROR.
%left	ANDAND.
%left	VBAR.
%left	CARET.
%left	AMPERSAND.
%left	EQ NE.
%left	GT GE LE LT.
%left	LSHIFT RSHIFT.
%left	ADD SUB.
%left	ASTERISK SLASH MOD.
%right	NOT TILDE INCR DECR SIZEOF PRE. // omitted duplicates: ADD SUB ASTERISK AMPERSAND
%left	LBRACKET LPAREN POINTER PERIOD POST.  // omitted duplicates: INCR DECR

program ::=
	PROGRAM NAME(n)
	program_param(pp)
	initial_defns(ds)
	entry(en)
	state_sets(ss)
	exit(ex)
        final_defns(fs).
{
	*presult =  node(D_PROG, n, pp, ds, en, ss, ex, fs);
}

program_param(p) ::= LPAREN string(x) RPAREN.	{ p = x; }
program_param(p) ::= .				{ p = 0; }

// Definitions

initial_defns(p) ::= initial_defns(xs) initial_defn(x). {
	p = link_node(xs, x);
}
initial_defns(p) ::= .				{ p = 0; }

initial_defn(p) ::= assign(x).			{ p = x; }
initial_defn(p) ::= monitor(x).			{ p = x; }
initial_defn(p) ::= sync(x).			{ p = x; }
initial_defn(p) ::= syncq(x).			{ p = x; }
initial_defn(p) ::= declaration(x).		{ p = x; }
initial_defn(p) ::= option(x).			{ p = x; }
initial_defn(p) ::= c_code(x).			{ p = x; }
initial_defn(p) ::= funcdef(x).			{ p = x; }
initial_defn(p) ::= structdef(x).		{ p = x; }

final_defns(p) ::= final_defns(xs) final_defn(x). {
	p = link_node(xs, x);
}
final_defns(p) ::= .				{ p = 0; }

final_defn(p) ::= c_code(x).			{ p = x; }
final_defn(p) ::= funcdef(x).			{ p = x; }
final_defn(p) ::= structdef(x).			{ p = x; }

assign(p) ::= ASSIGN variable(v) to string(t) SEMICOLON. {
	p = node(D_ASSIGN, v, 0, t);
}
assign(p) ::= ASSIGN variable(v) subscript(s) to string(t) SEMICOLON. {
	p = node(D_ASSIGN, v, node(E_CONST, s), t);
}
assign(p) ::= ASSIGN variable(v) to LBRACE(t) strings(ss) RBRACE SEMICOLON. {
	p = node(D_ASSIGN, v, 0, node(E_INIT, t, ss));
}
assign(p) ::= ASSIGN variable(v) SEMICOLON. {
	p = node(D_ASSIGN, v, 0, 0);
}

to ::= TO.
to ::= .

strings(p) ::= strings(xs) COMMA string(x).	{ p = link_node(xs, x); }
strings(p) ::= string(x).			{ p = x; }
strings(p) ::= .				{ p = 0; }

monitor(p) ::= MONITOR variable(v) opt_subscript(s) SEMICOLON. {
	p = node(D_MONITOR, v, s);
}
monitor(p) ::= MONITOR variable(v) opt_subscript(sub) error SEMICOLON. {
	p = node(D_MONITOR, v, sub);
	report("expected %s';'\n", sub ? "subscript or " : "");
}

sync(p) ::= SYNC variable(v) opt_subscript(s) to event_flag(f) SEMICOLON. {
	p = node(D_SYNC, v, s, node(E_VAR, f), 0);
}
sync(p) ::= SYNC variable(v) opt_subscript(s) to event_flag(f) error SEMICOLON. {
	p = node(D_SYNC, v, s, node(E_VAR, f), 0);
	report("expected ';'\n");
}

syncq(p) ::= SYNCQ variable(v) opt_subscript(s) to event_flag(f) syncq_size(n) SEMICOLON. {
	p = node(D_SYNCQ, v, s, node(E_VAR, f), n);
}
syncq(p) ::= SYNCQ variable(v) opt_subscript(s) syncq_size(n) SEMICOLON. {
	p = node(D_SYNCQ, v, s, 0, n);
}

%type event_flag {Token}
event_flag(p) ::= NAME(x).			{ p = x; }
%type variable {Token}
variable(p) ::= NAME(x).			{ p = x; }

syncq_size(p) ::= INTCON(n).			{ p = node(E_CONST, n); }
syncq_size(p) ::= .				{ p = 0; }

opt_subscript(p) ::= subscript(s).		{ p = node(E_CONST, s); }
opt_subscript(p) ::= .				{ p = 0; }

%type subscript {Token}
subscript(p) ::= LBRACKET INTCON(n) RBRACKET.	{ p = n; }

// Declarations

declaration(p) ::= basetype(t) init_declarators(ds) SEMICOLON.
							{ p = mk_decls(ds, t); }

init_declarators(p) ::= init_declarator(x).		{ p = x; }
init_declarators(p) ::= init_declarators(xs) COMMA init_declarator(x).
							{ p = link_node(xs, x); }

init_declarator(p) ::= declarator(x).			{ p = x; }
init_declarator(p) ::= declarator(x) EQUAL(t) init_expr(i).
							{ p = node(E_BINOP, t, x, i); }

declarator(p) ::= variable(n).				{ p = node(E_VAR, n); }
declarator(p) ::= declarator(x) subscript(s).	[POST]	{ p = node(E_SUBSCR, s, x, node(E_CONST, s)); }
declarator(p) ::= declarator(x)
	LPAREN(t) param_decls(ps) RPAREN.	[POST]	{ p = node(E_FUNC, t, x, ps); }
declarator(p) ::= LPAREN declarator(x) RPAREN.	[PRE]	{ p = x; }
declarator(p) ::= ASTERISK(t) declarator(x).	[PRE]	{ p = node(E_PRE, t, x); }
declarator(p) ::= CONST(t) declarator(x).	[PRE]	{ p = node(E_PRE, t, x); }

param_decls(p) ::= .					{ p = 0; }
param_decls(p) ::= param_decl(x).			{ p = x; }
param_decls(p) ::= param_decls(xs) COMMA param_decl(x).	{ p = link_node(xs, x); }

// allow parameter declaration with or without identifier
param_decl(p) ::= basetype(t) declarator(d).		{ p = mk_decl(d, t); }
param_decl(p) ::= type_expr(x).				{ p = x; }

// deprecated
declaration(p) ::= FOREIGN variables(ds) SEMICOLON.	{ p = mk_decls(ds, mk_no_type()); }

variables(p) ::= variable(x).				{ p = node(E_VAR, x); }
variables(p) ::= variables(xs) COMMA variable(x).	{ p = link_node(xs, node(E_VAR, x)); }

// Initializer
// Note: comma operator not allowed in 'expr'.
init_expr(p) ::= LPAREN(tc) type_expr(c) RPAREN LBRACE(tx) init_exprs(x) RBRACE.
							{ p = node(E_CAST, tc, c, node(E_INIT, tx, x)); }
init_expr(p) ::= LBRACE(t) init_exprs(x) RBRACE.	{ p = node(E_INIT, t, x); }
init_expr(p) ::= expr(x).				{ p = x; }

init_exprs(p) ::= init_exprs(xs) COMMA init_expr(x).	{ p = link_node(xs, x); }
init_exprs(p) ::= init_expr(x).				{ p = x; }
init_exprs(p) ::= .					{ p = 0; }

// Type expressions

// C standard calls this specifier-qualifier-list
%type prim_type {enum prim_type_tag}
prim_type(p) ::= CHAR.				{ p = P_CHAR; }
prim_type(p) ::= SHORT.				{ p = P_SHORT; }
prim_type(p) ::= INT.				{ p = P_INT; }
prim_type(p) ::= LONG.				{ p = P_LONG; }
prim_type(p) ::= UNSIGNED CHAR.			{ p = P_UCHAR; }
prim_type(p) ::= UNSIGNED SHORT.		{ p = P_USHORT; }
prim_type(p) ::= UNSIGNED INT.			{ p = P_UINT; }
prim_type(p) ::= UNSIGNED LONG.			{ p = P_ULONG; }
prim_type(p) ::= INT8T.				{ p = P_INT8T; }
prim_type(p) ::= UINT8T.			{ p = P_UINT8T; }
prim_type(p) ::= INT16T.			{ p = P_INT16T; }
prim_type(p) ::= UINT16T.			{ p = P_UINT16T; }
prim_type(p) ::= INT32T.			{ p = P_INT32T; }
prim_type(p) ::= UINT32T.			{ p = P_UINT32T; }
prim_type(p) ::= FLOAT.				{ p = P_FLOAT; }
prim_type(p) ::= DOUBLE.			{ p = P_DOUBLE; }
prim_type(p) ::= STRING.			{ p = P_STRING; }

%type basetype {Type*}
basetype(p) ::= prim_type(x).			{ p = mk_prim_type(x); }
basetype(p) ::= EVFLAG.				{ p = mk_ef_type(); }
basetype(p) ::= VOID.				{ p = mk_void_type(); }
basetype(p) ::= ENUM NAME(x).			{ p = mk_foreign_type(F_ENUM, x.str); }
basetype(p) ::= STRUCT NAME(x).			{ p = mk_foreign_type(F_STRUCT, x.str); }
basetype(p) ::= UNION NAME(x).			{ p = mk_foreign_type(F_UNION, x.str); }
basetype(p) ::= TYPENAME NAME(x).		{ p = mk_foreign_type(F_TYPENAME, x.str); }

type_expr(p) ::= basetype(t).			{ p = mk_decl(0, t); }
type_expr(p) ::= basetype(t) abs_decl(d).	{ p = mk_decl(d, t); }

// abstract_declarator
abs_decl(p) ::= LPAREN abs_decl(x) RPAREN.	{ p = x; }
abs_decl(p) ::= ASTERISK(t). [PRE]		{ p = node(E_PRE, t, 0); }
abs_decl(p) ::= ASTERISK(t) abs_decl(d). [PRE]	{ p = node(E_PRE, t, d); }
abs_decl(p) ::= CONST(t). [PRE]			{ p = node(E_PRE, t, 0); }
abs_decl(p) ::= CONST(t) abs_decl(d). [PRE]	{ p = node(E_PRE, t, d); }
abs_decl(p) ::= subscript(s). [POST]		{ p = node(E_SUBSCR, s, 0, node(E_CONST, s)); }
abs_decl(p) ::= abs_decl(d) subscript(s). [POST]{ p = node(E_SUBSCR, s, d, node(E_CONST, s)); }
abs_decl(p) ::= LPAREN(t) param_decls(ps) RPAREN. [POST]
						{ p = node(E_FUNC, t, 0, ps); }
abs_decl(p) ::= abs_decl(d) LPAREN(t) param_decls(ps) RPAREN. [POST]
						{ p = node(E_FUNC, t, d, ps); }

// not supported: empty brackets, empty parameter list
// abs_decl ::= LBRACKET RBRACKET.
// abs_decl ::= abs_decl LBRACKET RBRACKET.
// abs_decl ::= LPAREN RPAREN.
// abs_decl ::= abs_decl LPAREN RPAREN.

// Option spec

option(p) ::= OPTION option_value(v) NAME(n) SEMICOLON.
						{ p = opt_defn(n, v); }

%type option_value {Token}
option_value(p) ::= ADD(t).			{ p = t; }
option_value(p) ::= SUB(t).			{ p = t; }

// State sets and states

state_sets(p) ::= state_sets(xs) state_set(x).	{ p = link_node(xs, x); }
state_sets(p) ::= state_set(x).			{ p = x; }

state_set(p) ::= SS NAME(n) LBRACE ss_defns(ds) states(xs) RBRACE.
						{ p = node(D_SS, n, ds, xs); }

ss_defns(p) ::= ss_defns(xs) ss_defn(x).	{ p = link_node(xs, x); }
ss_defns(p) ::= .				{ p = 0; }

ss_defn(p) ::= assign(x).			{ p = x; }
ss_defn(p) ::= monitor(x).			{ p = x; }
ss_defn(p) ::= sync(x).				{ p = x; }
ss_defn(p) ::= syncq(x).			{ p = x; }
ss_defn(p) ::= declaration(x).			{ p = x; }

states(p) ::= states(xs) state(x).		{ p = link_node(xs, x); }
states(p) ::= state(x).				{ p = x; }

state(p) ::=
	STATE NAME(n) LBRACE state_defns(ds)
	entry(en) transitions(ws) exit(ex) RBRACE.
{
	p = node(D_STATE, n, ds, en, ws, ex);
}

state_defns(p) ::= state_defns(xs) state_defn(x). {
	p = link_node(xs, x);
}
state_defns(p) ::= .				{ p = 0; }

state_defn(p) ::= assign(x).			{ p = x; }
state_defn(p) ::= monitor(x).			{ p = x; }
state_defn(p) ::= sync(x).			{ p = x; }
state_defn(p) ::= syncq(x).			{ p = x; }
state_defn(p) ::= declaration(x).		{ p = x; }
state_defn(p) ::= option(x).			{ p = x; }

entry(p) ::= ENTRY(t) block(b).			{ p = node(D_ENTEX, t, b); }
entry(p) ::= .					{ p = 0; }

exit(p) ::= EXIT(t) block(b).			{ p = node(D_ENTEX, t, b); }
exit(p) ::= .					{ p = 0; }

transitions(p) ::= transitions(xs) transition(x).{ p = link_node(xs, x); }
transitions(p) ::= transition(x).		{ p = x; }

transition(p) ::= WHEN(t) LPAREN opt_expr(c) RPAREN block(b) STATE NAME(n). {
	t.str = n.str;
	p = node(D_WHEN, t, c, b);
}
transition(p) ::= WHEN(t) LPAREN opt_expr(c) RPAREN block(b) EXIT. {
	t.str = 0;
	p = node(D_WHEN, t, c, b);
}
transition(p) ::= WHEN(t) LPAREN opt_expr(c) RPAREN block(b) error. {
	t.str = 0;
	p = node(D_WHEN, t, c, b);
	report("expected 'state' or 'exit'\n");
}

block(p) ::= LBRACE(t) block_defns(ds) statements(xs) RBRACE. {
	p = node(S_CMPND, t, ds, xs);
}

block_defns(p) ::= block_defns(ds) block_defn(d). {
	p = link_node(ds, d);
}
block_defns(p) ::= .				{ p = 0; }

block_defn(p) ::= declaration(x).		{ p = x; }
block_defn(p) ::= c_code(x).			{ p = x; }

// Statements

statements(p) ::= statements(xs) statement(x).	{ p = link_node(xs, x); }
statements(p) ::= .				{ p = 0; }

statement(p) ::= BREAK(t) SEMICOLON.		{ p = node(S_JUMP, t); }
statement(p) ::= CONTINUE(t) SEMICOLON.		{ p = node(S_JUMP, t); }
statement(p) ::= RETURN(t) opt_expr(x) SEMICOLON.
						{ p = node(S_RETURN, t, x); }
statement(p) ::= STATE NAME(t) SEMICOLON.	{ p = node(S_CHANGE, t); }
statement(p) ::= c_code(x).			{ p = x; }
statement(p) ::= block(x).			{ p = x; }
statement(p) ::= IF(t) LPAREN comma_expr(c) RPAREN statement(th).
						{ p = node(S_IF, t, c, th, 0); }
statement(p) ::= IF(t) LPAREN comma_expr(c) RPAREN statement(th) ELSE statement(el).
						{ p = node(S_IF, t, c, th, el); }
statement(p) ::= WHILE(t) LPAREN comma_expr(c) RPAREN statement(x).
						{ p = node(S_WHILE, t, c, x); }
statement(p) ::= for_statement(x).		{ p = x; }
statement(p) ::= opt_expr(x) SEMICOLON(t).	{ p = node(S_STMT, t, x); }
// statement(p) ::= error SEMICOLON(t).		{ p = node(S_STMT, t, 0); report("malformed expression\n"); }

for_statement(p) ::=
	FOR(for) LPAREN
	opt_expr(init) SEMICOLON opt_expr(cond) SEMICOLON opt_expr(iter)
	RPAREN statement(st).		{ p = node(S_FOR, for, init, cond, iter, st); }

// Expressions

// Note: the non-terminal 'expr' does not include application of the comma operator.
// Comma separated lists of 'expr' can be: function arguments (non-terminal
// 'args')and applications of the comma operator (non-terminal 'comma_expr').

// Atomic
expr(p) ::= INTCON(x).				{ p = node(E_CONST, x); }
expr(p) ::= FPCON(x).				{ p = node(E_CONST, x); }
expr(p) ::= string(x).				{ p = x; }
expr(p) ::= variable(v).			{ p = node(E_VAR, v); }

// Primary Expression and Unary Postfix Operators
expr(p) ::= LPAREN(t) comma_expr(x) RPAREN.		{ p = node(E_PAREN,  t, x); }
expr(p) ::= expr(x) LPAREN(t) args(y) RPAREN.		{ p = node(E_FUNC,   t, x, y); }
expr(p) ::= EXIT(n) LPAREN(t) args(y) RPAREN.		{ p = node(E_FUNC,   t, node(E_VAR, n), y); }
expr(p) ::= SIZEOF(n) LPAREN(t) type_expr(y) RPAREN.	{ p = node(E_FUNC,   t, node(E_VAR, n), y); }
expr(p) ::= expr(x) LBRACKET(t) expr(y) RBRACKET.	{ p = node(E_SUBSCR, t, x, y); }
expr(p) ::= expr(x) PERIOD(t) member(y).		{ p = node(E_SELECT, t, x, y); }
expr(p) ::= expr(x) POINTER(t) member(y).		{ p = node(E_SELECT, t, x, y); }
expr(p) ::= expr(x) INCR(t). [POST]			{ p = node(E_POST,   t, x); }
expr(p) ::= expr(x) DECR(t). [POST]			{ p = node(E_POST,   t, x); }

// Unary Prefix Operators
expr(p) ::= ADD(t)	expr(x). [PRE]		{ p = node(E_PRE, t, x); }
expr(p) ::= SUB(t)	expr(x). [PRE]		{ p = node(E_PRE, t, x); }
expr(p) ::= ASTERISK(t)	expr(x). [PRE]		{ p = node(E_PRE, t, x); }
expr(p) ::= AMPERSAND(t)expr(x). [PRE]		{ p = node(E_PRE, t, x); }
expr(p) ::= NOT(t)	expr(x). [PRE]		{ p = node(E_PRE, t, x); }
expr(p) ::= TILDE(t)	expr(x). [PRE]		{ p = node(E_PRE, t, x); }
expr(p) ::= INCR(t)	expr(x). [PRE]		{ p = node(E_PRE, t, x); }
expr(p) ::= DECR(t)	expr(x). [PRE]		{ p = node(E_PRE, t, x); }
expr(p) ::= SIZEOF(t)	expr(x). [PRE]		{ p = node(E_FUNC, t, node(E_VAR, t), x); }

// Type Cast
expr(p) ::= LPAREN(t) type_expr(c) RPAREN expr(x). [PRE] { p = node(E_CAST, t, c, x); }

// Binary Operators, left-to-right
expr(p) ::= expr(x) SUB(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) ADD(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) ASTERISK(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) SLASH(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) GT(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) GE(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) EQ(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) NE(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) LE(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) LT(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) OROR(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) ANDAND(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) LSHIFT(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) RSHIFT(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) VBAR(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) CARET(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) AMPERSAND(t) expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) MOD(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }

// Ternary Operator, right-to-left
expr(p) ::= expr(c) QUESTION(t) expr(th) COLON expr(el).
						{ p = node(E_TERNOP, t, c, th, el); }

// Assignment Operators, right-to-left
expr(p) ::= expr(x) EQUAL(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) ADDEQ(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) SUBEQ(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) ANDEQ(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) OREQ(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) DIVEQ(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) MULEQ(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) MODEQ(t) 	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) LSHEQ(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) RSHEQ(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }
expr(p) ::= expr(x) XOREQ(t)	expr(y).	{ p = node(E_BINOP, t, x, y); }

// Comma, left-to-right
comma_expr(p) ::= comma_expr(xs) COMMA(t) expr(x).	{ p = node(E_BINOP, t, xs, x); }
comma_expr(p) ::= expr(x).				{ p = x; }

opt_expr(p) ::= comma_expr(x).			{ p = x; }
opt_expr(p) ::= .				{ p = 0; }

// Function arguments
// Syntactically the same as opt_expr but interpreted differently.
args(p) ::= args(xs) COMMA expr(x).		{ p = link_node(xs, x); }
args(p) ::= expr(x).				{ p = x; }
args(p) ::= .					{ p = 0; }

string(p) ::= STRCON(t).			{ p = node(E_STRING, t); }

member(p) ::= NAME(t).				{ p = node(E_MEMBER, t); }

// Function Definitions

funcdef(p) ::= basetype(t) declarator(d) block(b). {
	p = node(D_FUNCDEF, d->token, mk_decl(d, t), b);
}

// Struct Definitions

structdef(p) ::= STRUCT NAME(t) members(ds) SEMICOLON.		{ p = node(D_STRUCTDEF, t, ds); }

members(p) ::= LBRACE member_decls(xs) RBRACE.			{ p = xs; }

member_decls(p) ::= member_decl(x).				{ p = x; }
member_decls(p) ::= member_decls(xs) member_decl(x).		{ p = link_node(xs, x); }

member_decl(p) ::= basetype(t) declarator(d) SEMICOLON.		{ p = mk_decl(d, t); }
member_decl(p) ::= c_code(x).					{ p = x; }

// Literal (C) code

c_code(p) ::= CCODE(t). 			{ p = node(T_TEXT, t); }
