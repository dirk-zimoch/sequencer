/*************************************************************************\
Copyright (c) 1993      The Regents of the University of California
                        and the University of Chicago.
                        Los Alamos National Laboratory
Copyright (c) 2010-2015 Helmholtz-Zentrum Berlin f. Materialien
                        und Energie GmbH, Germany (HZB)
This file is distributed subject to a Software License Agreement found
in the file LICENSE that is included with this distribution.
\*************************************************************************/
/*	Interface between snc generated code and run-time library
 *
 *	Author:		Andy Kozubal
 *	Date:		01mar94
 *
 *	Experimental Physics and Industrial Control System (EPICS)
 *
 *	This software was produced under  U.S. Government contracts:
 *	(W-7405-ENG-36) at the Los Alamos National Laboratory,
 *	and (W-31-109-ENG-38) at Argonne National Laboratory.
 *
 *	Initial development by:
 *		The Controls and Automation Group (AT-8)
 *		Ground Test Accelerator
 *		Accelerator Technology Division
 *		Los Alamos National Laboratory
 */
#ifndef INCLseqsnch
#define INCLseqsnch

#include "shareLib.h"
#include "seqCom.h"
#include "seq_prim_types.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef epicsUInt32 seqMask;				/* for event masks and options */

/* Bit encoding for run-time options */
#define OPT_DEBUG		((seqMask)1u<<0)	/* turn on debugging */
#define OPT_ASYNC		((seqMask)1u<<1)	/* use async. gets */
#define OPT_CONN		((seqMask)1u<<2)	/* wait for all connections */
#define OPT_REENT		((seqMask)1u<<3)	/* generate reentrant code */
#define OPT_NEWEF		((seqMask)1u<<4)	/* new event flag mode */
#define OPT_SAFE		((seqMask)1u<<5)	/* safe mode */

/* Bit encoding for state specific options */
#define OPT_NORESETTIMERS	((seqMask)1u<<0)	/* Don't reset timers on */
							/* entry to state from same state */
#define OPT_DOENTRYFROMSELF	((seqMask)1u<<1)	/* Do entry{} even if from same state */
#define OPT_DOEXITTOSELF	((seqMask)1u<<2)	/* Do exit{} even if to same state */

/* seqMask macros */
#define NBITS			(8*sizeof(seqMask))	/* # bits in seqMask word */
#define NWORDS(maxBitNum)	(1+(maxBitNum)/NBITS)	/* # words in seqMask */

#define bitSet(words, bitnum)	( (words)[(bitnum)/NBITS] |=  (1u<<((bitnum)%NBITS)))
#define bitClear(words, bitnum)	( (words)[(bitnum)/NBITS] &= ~(1u<<((bitnum)%NBITS)))
#define bitTest(words, bitnum)	(((words)[(bitnum)/NBITS] &  (1u<<((bitnum)%NBITS))) != 0)

#ifndef TRUE
#define TRUE	1
#endif
#ifndef FALSE
#define FALSE	0
#endif

typedef	struct program_instance *const PROG_ID;

/* Prototypes for functions generated by snc */
typedef void SEQ_TRANS_FUNC(SS_ID ssId, int transNum, int *nextState);
typedef seqBool SEQ_EVENT_FUNC(SS_ID ssId, int *transNum, int *nextState);
typedef void SEQ_SS_FUNC(SS_ID ssId);
typedef void SEQ_PROG_FUNC(PROG_ID progId);

typedef const struct seqState seqState;
typedef const struct seqSS seqSS;

/* Static information about a state */
struct seqState
{
	const char	*stateName;	/* state name */
	SEQ_TRANS_FUNC	*actionFunc;	/* action routine for this state */
	SEQ_EVENT_FUNC	*eventFunc;	/* event routine for this state */
	SEQ_SS_FUNC	*entryFunc;	/* statements performed on entry to state */
	SEQ_SS_FUNC	*exitFunc;	/* statements performed on exit from state */
	const seqMask	*eventMask;	/* event mask for this state */
	seqMask		options;	/* state option mask */
};

/* Static information about a state set */
struct seqSS
{
	const char	*ssName;	/* state set name */
	seqState	*states;	/* array of state blocks */
	unsigned	numStates;	/* number of states in this state set */
};

/* Static information about a state program */
struct seqProgram
{
	unsigned	magic;		/* magic number */
	const char	*progName;	/* program name (for debugging) */
	unsigned	numChans;	/* number of db channels */
	seqSS		*ss;		/* array of state set info structs */
	unsigned	numSS;		/* number of state sets */
	unsigned	varSize;	/* # bytes in user variable area */
	const char	*params;	/* program paramters */
	unsigned	numEvFlags;	/* number of event flags */
	seqMask		options;	/* program option mask */
	SEQ_PROG_FUNC	*initFunc;	/* init function */
	SEQ_SS_FUNC	*entryFunc;	/* entry function */
	SEQ_SS_FUNC	*exitFunc;	/* exit function */
	unsigned	numQueues;	/* number of syncQ queues */
};

epicsShareFunc evflag seq_efCreate(PROG_ID sp, unsigned ef_num, unsigned val);
epicsShareFunc void seq_exit(SS_ID);

epicsShareFunc CH_ID seq_pvCreate(
	struct program_instance	*sp,	/* program instance */
	unsigned	chNum,		/* index of channel */
	const char	*chName,	/* assigned channel name */
	size_t		offset,		/* offset to value */
	const char	*varName,	/* variable name, including subscripts*/
	enum prim_type_tag varType,	/* variable (base) type */
	unsigned	count,		/* element count for arrays */
	evflag		ef,		/* event flag if synced */
	unsigned	queueSize,	/* syncQ queue size (0=not queued) */
	unsigned	queueIndex);	/* syncQ queue index */

epicsShareFunc void seq_pvAddMonitor(
	struct program_instance	*sp,	/* program instance */
	CH_ID		ch,		/* channel object */
	unsigned	ssNum);		/* state set number */

epicsShareFunc size_t seq_pvOffset(CH_ID ch);

#define seq_pvValue(type,ch) (*(type)(seq_pvOffset(ch)+(size_t)seqg_var))

/* called by generated main and registrar routines */
epicsShareFunc void seqRegisterSequencerProgram(seqProgram *p);
epicsShareFunc void seqRegisterSequencerCommands(void);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif	/*INCLseqsnch*/
